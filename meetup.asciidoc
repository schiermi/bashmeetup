= bash Meetup
Andreas Schiermeier <andreas@schiermeier.name>
:encoding: utf-8
:lang: de
:data-uri:

== env

[source,bash]
-------------------------------------------------
USER="schiermi"
NAME="Andreas Schiermeier"
EMAIL="andreas@schiermeier.name"
TWITTER="@schiermi"
EMPLOYER="FactSet Digital Solutions GmbH"
_=("üêß@üíª" "üö¥" "https://ccc-ffm.de/")
-------------------------------------------------

== Shells (sh, ksh, bash, zsh)

=== Was ist eine Shell, bash
* lt. `man 1 bash` ein "command language interpreter"
** "Programmiersprache f√ºr Betriebssystemprozesse"
** direkte Kommandoeingabe (interaktive Shell)
** Kommandos nach einem "Drehbuch" (Shellskript).

Interaktiv kann der Bediener auf unvorhergesehene (Fehler) reagieren. Passiert im Script zuviel Unbedachtes muss √∂fters gedreht oder dass Drehbuch werden.

=== Geschichte
*  Anfang der 1970er Jahre: Unix-Shells
* Ende der 1970er: Stephen R. *Bourne Shell*, sh, Basis aktueller UNIX-shells; sowie ksh, csh
* Ende der 1980er: bash bourne again shell vereint und erweitert bekannte Features
* Anfang der 1990er: zsh, weitere neue Ans√§tze, werden teilweise auch in bash √ºbernommen
* Aktuell: bash auf vielen Systemen verf√ºgbar und die Standardshell; Geschichte "erlebbar"

== Usability (im interaktiven Betrieb)

* Vorraussetzung & Einstiegsh√ºrde: Kommandos m√ºssen bekannt sein
* ; (Semikolon): separiert mehrere Anweisungen in einer Eingabezeile
* ‚èé (Zeilenschaltung, newline): Bringt Anweisungen zur Ausf√ºhrung
* einige (wichtige) Tastenkombinationen mit ‚ú≤ (Strg, Steuerung, Ctrl, Control)
|=============================================================================
| ‚ú≤+C | Eingabe oder Programmausf√ºhrung abbrechen (genauer: sendet Signal 2, SIGINT)
| ‚ú≤+D | Sende EOF (beende die Eingabe)
| ‚ú≤+R | In der Befehlszeilenhistorie suchen
| ‚ú≤+S | Terminal Flusskontrolle Stopp
| ‚ú≤+Q | Terminal Flusskontrolle Fortsetzen
| ‚ú≤+Z | Vordergrundprogramm in interaktiver Shell mit Jobcontrol anhalten (sende Signal 19, SIGSTOP)
| ‚ú≤+A | Springe in der Befehlszeile an den Anfang (via readline)
| ‚ú≤+E | Springe in der Befehlszeile an das Ende (via readline)
| ‚Üê ‚Üí | Innerhalb der Befehlszeile navigieren
| ‚Üë ‚Üì | Innerhalb der Befehlszeilenhistorie navigieren
|=============================================================================

[NOTE]
Unter Umst√§nden werden Tastenkombinationen vom Betriebssystem, der grafischen Benutzeroberfl√§che oder dem Terminalemulator abgefangen.
Desweiteren k√∂nnen Terminal (tty) oder die readline Bibliothek abweichend arbeiten

== Kommandos: Programme

Programme sind per Dateisystempfad vom Betriebssystem auffindbar und werden diesem zur Ausf√ºhrung √ºberlassen.

- `/bin/ls`
- `/bin/mv`

== Kommandos: Builtins

Builtins sind aus Effizienzs- oder Machbarkeitsgr√ºnden von der Shell *selbst* abgearbeitete Befehle.

.Effizienz
- `pwd`
- `test`
- `[`
- (`time`)

.Machbarkeit
- `cd`
- `read`
- `return`
- `exit`
- `[[`
- `builtin`
- `command`

.Siehe auch
- `man 1 bash`, SHELL BUILTIN COMMANDS
- `help`
- `help builinname`


== Kommandos: Funktionen

Funktionen fassen mehrere Kommandos als benannte Subroutine zusammen (vergleichbar zu Programmiersprachen).

.Definition
[source,bash]
-------------------------------------------------
function fname () {
  echo "Mein Name ist ${FUNCNAME}."
  return 0
}
-------------------------------------------------

[source,bash]
.Welche Funktionen gibt es?
-------------------------------------------------
declare -F
-------------------------------------------------

[source,bash]
.‚Ä¶inkl. Definition?
-------------------------------------------------
declare -f
-------------------------------------------------

== Kommandos: Aliase

Aliase dienen als Abk√ºrzung f√ºr h√§ufig genutzte Aufrufe.

[source,bash]
-------------------------------------------------
# Eingabe von "la" f√ºhrt "ls -la" aus
alias la='ls -la'

# Eingabe von "cd.." f√ºhrt "cd .." aus
alias cd..='cd ..'

# Aliase auflisten
alias

# Alias l√∂schen
unalias la
-------------------------------------------------

Suchreihenfolge: Alias, Funktion, Builtin, Programm (Suche anhand PATH)

.Siehe auch
- `man 1 bash`, "COMMAND EXECUTION"

== Variablen & Arrays - Deklaration, Zuweisung

|=============================================================================
| `variable='inhalt'` | Deklaration bei erster Zuweisung
| `declare variable` | Deklaration ohne Zuweisung
| `declare variable='inhalt'` |
| `declare -i variable=1542650400` | Ganzzahl, Zuweisung einer Zeichenkette ergibt 0!
| `declare -ri c='299792458'`      | Ganzzahl, readonly
| `unset variable`                 | Variable l√∂schen
| `declare -a indexarray=( 'Stickstoff' 'Sauerstoff' 'Rest' )` | Indiziertes Array (Startindex: 0)
| `declare -A keyarray=( ['VW']='Abschalteinrichtung' ['Frankfurt']='Stimmenz√§hlung' )` | Textindiziertes Array
| `unset array`                    | ganzes Array l√∂schen
| `unset array[index]`             | Wert an Index in Array l√∂schen
|=============================================================================

[NOTE]
Innerhalb von Funktionen zur Begrenzung des G√ºltigkeitsbereichs `local` statt `declare` verwenden.

== Variablen & Arrays - Verwendung

.einfache Variablen
* Zugriff auf einfache Variablen: `$variable`
** ‚Ä¶oder besser: `${variable}`

.Arrays
* Zugriff auf das zweite Element des Arrays (Index 1): `${indexarray[1]}`
* Alle Elemente: `${indexarray[@]}`
* Anzahl der Elemente: `${#indexarray[@]}`

.textindizierte Arrays
* Zugriff auf Element des Index "key": `${keyarray["key"]}`
* Alle Keys: `${!keyarray[@]}`
* Alle Elemente: `${keyarray[@]}`

[source,bash]
.Beispiele
-------------------------------------------------
echo "${HOME}"
echo "${indexarray[1]}"
echo "${keyarray["Frankfurt"]}"
-------------------------------------------------

== "besondere" Variablen

|=============================================================================
| `$0` | Scriptname
| `$#` | Anzahl der √ºbergebenen Parameter
| `$1, `$2`, ‚Ä¶ `$9` | dem Script √ºbergebene Parameter
| `${10}`, `${11}`, ‚Ä¶ | dem Script √ºbergebene Parameter (> 9)
| `$*` | dem Script √ºbergebene Parameter als String verbunden
| `$@` | dem Script √ºbergebene Parameter als Array
| `$$` | Prozess-ID der Shell
| `$?` | Fehlercode des zuletzt beendeten Programms
| `${PPID}` | Prozess-ID des Elternprozesses
| `${HOSTNAME}` | Hostname des das Script ausf√ºhrenden Systems
| `${PWD}` | aktuelles Arbeitsverzeichnis
| `${HOME}` | Hauptverzeichnis des angemeldeten Benutzers; Ziel f√ºr "cd" und Wert von ~
| `${PATH}` | Suchpfad f√ºr ohne vollen Pfad aufgerufene *Programme*
|=============================================================================

== "besondere" Variablen - PATH

=== Beispiel "ls"

`PATH="/home/as/bin:/usr/local/bin:/usr/bin:/bin:/usr/lib/mit/sbin"`

.Suche nach (erster Treffer "gewinnt"):
- /home/as/bin/ls
- /usr/local/bin/ls
- /usr/bin/ls
- /bin/ls
- /usr/lib/mit/sbin/ls

."Suchergebnis" wird f√ºr die Laufzeit der Shell vermerkt!
- Suchcache anzeigen: hash -l
- Suchcache leeren: hash -r

.Siehe auch
- `man 1 bash`, PARAMETERS

== Parametertrennung - IFS

Noch eine Variable mehr: IFS

- `${IFS}`: *Internal Field Separator*
- Trennzeichen f√ºr die "Generierung" von Parametern aus Variablen.
- Standard: Leerzeichen, Tabulator, Zeilenumbruch
- `unset` IFS stellt den Standard wiederher (nicht: IFS="").

[NOTE]
Das erste Zeichen aus IFS wird bei `"$*"` als Verbindungszeichen der Elemente verwendet.

- Demo: `demo/params.sh`

== Platzhalter & Textersetzung in Kommandos - Variablen

Allgemein: Textersetzungen im eingegebenen oder eingelesenen Kommando.

- Es wird etwas Anderes ausgef√ºhrt als eingegeben.

[source,bash]
.*Variablen* bereits bekannt
-------------------------------------------------
echo "${HOME}"
-------------------------------------------------

== Platzhalter & Textersetzung in Kommandos - Wildcards

*Wildcards (√ºblicherweise anhand von Dateinamen)*
|================================================
|`*`     | keines bis beliebig viele Zeichen
|`?`     | exakt ein beliebiges Zeichen
|`[0-9]` | ein Zeichen aus dem angegebenen Bereich
|================================================

- Wildcards sind kombinierbar
- Nicht mit RegEx z.B. "`grep`" (regul√§ren Ausdr√ºcken verwechseln)!

[source,bash]
-------------------------------------------------
ls -l [0-9]*.csv
-------------------------------------------------

== Platzhalter & Textersetzung in Kommandos - Berechnungen, Klammererweiterung

[source,bash]
.Berechnungen via $(( ‚Ä¶ ))
-------------------------------------------------
i=2
echo $(( i + 2 ))
-------------------------------------------------

[source,bash]
.Klammererweiterung via Zeichenbereiche z.B.: {2000..2018}{01..12}{a..f}.txt
-------------------------------------------------
echo {2000..2018}{01..12}{a..f}.txt
-------------------------------------------------

== Platzhalter & Textersetzung in Kommandos - Prozesssubstitution, ~


[source,bash]
.Prozesssubstitution Ausgabe (STDOUT) von anderen Programmen als Parameter nutzen
-------------------------------------------------
echo "Externe IP: $(curl -s ifconfig.co)"

# veraltet, nicht verschachtelbar:
echo "Externe IP: `curl -s ifconfig.co`"

# √§hnlich: Dateiinhalt als Parameter nutzen
echo "$(< /etc/passwd)"
-------------------------------------------------

[source,bash]
.`~`
-------------------------------------------------
# Wert von ${HOME}
echo ~
# HOME-Verzeichnis eines (anderen) Benutzers
echo ~root
-------------------------------------------------

== Ausgabeumleitung, Pipes

|==========================================================================
| cmd1 \| cmd2 | STDOUT von cmd1 mit STDIN von cmd2 verbinden
| cmd1 \|& cmd2 | STDOUT und STDERR von cmd1 mit STDIN von cmd2 verbinden
| cmd > datei | STDOUT von cmd datei schreiben
| cmd >> datei | STDOUT von cmd an datei anh√§ngen
| cmd < datei | STDIN f√ºr cmd aus datei einlesen
| cmd1 < <( cmd2 ) | STDOUT der Subshell von cmd2 als STDIN f√ºr cmd1
|==========================================================================

- Demo: `demo/stdouterr-echo.sh`
- Demo: `demo/stdouterr-ls.sh`

== Hashbang - der Anfang vom Script

=== Hintergrund
Im Allgemeinen signalisiert der Hashbang (#!) dem Betriebssystem dass diese Datei
nicht als Bin√§rdatei ausgef√ºhrt werden kann, sondern ein Interpreter zu Hilfe genommen werden soll.

=== M√∂gliche Varianten
|=============================================================================
| #!/bin/bash         | eindeutig, bash muss jedoch in /bin vorhanden sein
| #!/bin/sh           | sollte nicht verwendet werden, wenn bash-Features verwendet werden
| #!/usr/bin/env bash | findet bash (oder generell den angegebenen Interpreter auch an ungew√∂hnlichen Pfaden; ben√∂tigt aber im Gegenzug einen Zwischenschritt
|=============================================================================
  
== Der Anfang vom Script - was sonst noch praktisch ist

=== Laufzeiteinstellungen - better safe than sorry

|=============================================================================
| `set -o nounset` | Zugriff auf uninitialisierte Variablen erzeugt einen Fehler
| `set -o errexit` | Nicht abgefangene Fehler (rc != 0) beenden das Script
| `set -o pipefail` | Fehler in Pipes-Ketten werden als Fehler des gesamten Konstrukts gewertet
| `set -o noclobber` | verhindert das √úberschreiben bestehender Dateien mit `cmd > datei` erzwingen mit `cmd >\| datei`
| `IFS=$'\n\t'` | verhindert, dass Leerzeichen als Worttrenner verwendet werden
|=============================================================================

=== Tools & Styleguide

|=============================================================================
| https://www.shellcheck.net/ | Untersucht Script auf potenzielle Fehlerquellen
| https://google.github.io/styleguide/shell.xml | Styleguide f√ºr Shellskripte 
|=============================================================================

== Der Ende vom Script - Aufr√§umen!

[source,bash]
-------------------------------------------------
tmpfile="$(mktemp)"

function cleanup() {
  rm -f "${tmpfile}"
}

trap "cleanup" exit
-------------------------------------------------

== Tolle Tools

- `xargs`
- `tr`
- `iconv`
- `jq` (ggf. glowforge.sh)

== EOF

[source,bash]
-------------------------------------------------
xdg-open "https://github.com/schiermi/bashmeetup/"
echo "andreas@schiermeier.name - @schiermi"
echo "Danke f√ºr das Interesse!"
~adt/guest
echo "$?"
-------------------------------------------------
